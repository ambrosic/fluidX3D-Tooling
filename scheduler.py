import json
from enum import Enum
from git import Repo
import subprocess
import os
from multiprocessing import Process
import re

# requires the gitPython library, if not installed, run ``pip install gitpython``.



configRaw = open('config.json')

config = json.load(configRaw)

target = config['targetPlatform']

repoPath = "temp/fx3d"

#relative path for image files inside of the repo folder.
imageParentFolder = "bin/export"

# where should the converted videos go?
videoOutput = "bin/videoOutput"

# for case switching on stuff that's platform dependent
class platform(Enum):
    BEOSHOCK="BEOSHOCK" # Wichita State University's SLURM-controlled HPC Node
    GENERIC_HPC="GENERIC_HPC" # Singular Linux-running HEDT / HPC machine
    WINDOWS="WINDOWS" # single machine running Windows with WSL2 installed (also assumes you're using Ubuntu on WSL).



# I'll be writing these steps as if for BeoShock and not anything else for starters.
# once this script is capable of running on beoShock, we'll go from there.

# STEP ONE: CLONE THE REPOSITORY
def clone_or_checkout_repository(repo_url, local_folder, branch='master'):
    try:
        # Attempt to open the repository (checks if it exists)
        repo = Repo(local_folder)
        print(f"Repository found at {local_folder}")
    except:
        # If the repository doesn't exist, clone it
        repo = Repo.clone_from(repo_url, local_folder, branch=branch)
        print(f"Cloned repository from {repo_url} to {local_folder}")

    # Checkout the specified branch
    repo.git.checkout(branch)
    repo.git.reset('--hard')
    repo.remotes.origin.pull()
    
    print(f"Checked out branch: {branch}")



clone_or_checkout_repository(config['repository']['url'],repoPath , config['repository']['branch'])


# STEP TWO: chmod all scripts in this repo's base folder and in FluidX3D's base folder.

def list_bash_files(directory_path):
    bash_files = [os.path.join(directory_path,f) for f in os.listdir(directory_path) if os.path.isfile(os.path.join(directory_path, f)) and f.endswith(".sh")]
    return bash_files

def touch_files(files):
    for file in files:
        # subprocess.run(["chmod",f"+x {file}"])
        os.chmod(file,0o755)

processingScripts = list_bash_files(".")
touch_files(processingScripts)
# print(processingScripts)

repoScripts = list_bash_files(repoPath)
# print(repoScripts)
touch_files(repoScripts)

def cleanJobID(inputString):
    return str(re.sub("\D",'',str(inputString).rstrip()))

# STEP THREE: RUN / SCHEDULE BUILD SCRIPT

makeExecutionID = ""

if(target == platform.BEOSHOCK.value):
    print("Running Beoshock Make Command")
    makeExecutionID = cleanJobID(subprocess.check_output(["sbatch",f"batchjob.sh {target}"]))
    print(makeExecutionID)
elif(target == platform.WINDOWS.value):
    print("Build on local platform")
    subprocess.run(['bash',f"batchjob.sh {target}"])
elif(target == platform.GENERIC_HPC.value):
    print("Running on Linux machine")
    print(subprocess.check_output(['./batchjob.sh',f'{target}']))


# STEP FOUR: RUN/SCHEDULE FFmpeg video encoding per-camera

def get_immediate_subdirectories(directory):
    '''generated by MS Copilot, returns all subfolders in a directory.'''
    return [f for f in os.listdir(directory) if os.path.isdir(os.path.join(directory, f))]


try:
    imageFolders = get_immediate_subdirectories(os.path.join(repoPath,imageParentFolder))
except:
    print("unable to load folders, skipping post-process scheduler")
    exit()


subprocessIDs = []
if(target == platform.BEOSHOCK.value):
    print("Scheduling Post-Processor on BeoShock")
    for dir in imageFolders:
        inputPath = os.path.join(repoPath,imageParentFolder,dir)
        subprocessIDs.append(cleanJobID(subprocess.check_output(["sbatch",f"--parsable --dependency=aftercorr:{makeExecutionID} postprocess_python.sh {inputPath} {videoOutput} {dir}"])))
    
elif(target == platform.GENERIC_HPC.value):
    print("Scheduling Post-Processor on Local Machine")
    for dir in imageFolders:
        inputPath = os.path.join(repoPath,imageParentFolder,dir)
        print(f'{dir}',subprocess.check_output(['bash',f'postprocess_python.sh {inputPath} {videoOutput} {dir}']))

print(subprocessIDs)



# # test = subprocess.run(["Write-Host","hi"])
# test1 = subprocess.run(['wsl',"chmod u+x temp/test/make.sh"],cwd=os.getcwd())
# test3 = subprocess.run(['wsl','ls'])
# test2 = subprocess.run(['wsl',"temp/test/make.sh"])
# test2.args
# print("completed testing")

